# Вариант 1 (МАТ)

- Для выполнения работы использовалась библиотека `automata-lib` для Python, 
которая предоставляет огромный набор функций для работы с автоматами.

## Генерация лабиринта
Для генерации лабиринта сначала генерируется случайное регулярное выражение
длины, равной ограничению сверху из файла `parameters.txt`, 
по которому затем строится НКА с помощью метода 
`from_regex`. Проводится детерминизация НКА, а в полученном 
ДКА удаляются финальные состояния, которые не являются тупиковыми
(такая ситуация возможна из-за случайной генерации регулярок). 
Стоит отметить, что язык итогового лабиринта не совпадает с языком
регулярки, с помощью которой он генерировался 
(из-за удаления финальных состояний и возможных последующих
преобразований, описанных ниже). Если количество состояний полученного
лабиринта больше ограничения (происходит нечасто), то проводится
перегенерация лабиринта.

## Установка и запуск
- Необходимо установить нужные библиотеки из файла `requirements.txt`:
```bash
pip install -r requirements.txt
```
- Аналогичный вариант для пользователей `poetry`:
```bash
poetry install
```
- Запуск программы производится из папки `lab2tfl` командой
```bash
python3 main.py [-p yes]
```
где `[-p yes]` - необязательный аргумент, при введении которого лабиринт
гарантированно будет планарным (нужно, если лёрнер использует специальные
эвристики).
Ограничение на число состояний и количество выходов 
вводится в файл `parameters.txt`
- После запуска изображение лабиринта будет сохранено в папку `images` 
с названием `labyrinth.png`.
- После удачной попытки лёрнера в папку `videos` сохраняется видео 
с названием `labyrinth_attempts.mp4` с 
изменением лабиринта с течением времени.

После запуска программы HTTP-сервер запускается на порту `8095` и ожидает
HTTP-POST запросов.

## Формат приёма данных
- Запрос "membership" - POST на `/checkWord` в виде JSONа:

```json
{
    "word": "LLRLR"
}
```
В ответ вернётся JSON
```json
{
    "response": true
}
```
(если строка не принадлежит языку) или 
```json
{
    "response": false
}
```
(если принадлежит).

- Запрос "equivalence" - POST на `/checkTable` в виде JSONа:

```json
{
  "main_prefixes": "ε L R RL RR",
  "non_main_prefixes": "LL LR RLL RLR RRL RRR",
  "suffixes": "ε LRL RL L ", 
  "table": "1 0 0 0 0 0 1 0 1 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0"
}
```

Здесь `main_prefixes` - префиксы из основной части таблицы,

`non_main_prefixes` - префиксы из расширенной части таблицы,

`suffixes` - суффиксы,

`table` - таблица в виде строки. То есть, например, если таблица 
состоит из 3 префиксов и 4 суффиксов, то сначала в этой строке идут
3 значения первой строки таблицы, затем 3 значения второй строки и так далее.


Здесь обязательно нужно поставить `ε` для пустой строки!

Если лабиринт МАТа имеет слова, которые не принадлежат языку
пользователя, то в ответ вернётся JSON, где в поле `type` лежит `true`,
а в поле `response` - контрпример:

```json
{
    "type": true,
    "response": "LLR"
}
```

Если язык автомата пользователя полностью содержит язык автомата МАТа
и содержит некоторые дополнительные слова, которые не принадлежат лабиринту,
то в ответ вернётся JSON, где в поле `type` лежит `false`,
а в поле `response` - контрпример:

```json
{
    "type": false,
    "response": "LLR"
}
```

Если лабиринты эквивалентны, то вернется JSON с null'ами:

```json
{
    "type": null,
    "response": null
}
```

### Основные моменты генерации
- Из-за моих хитростей с регулярками случайный планарный лабиринт с проведённой
минимизацией почти всегда получается намного меньше верхней границы 
по количеству вершин,
поскольку сначала генерируется регулярка, затем она переводится в НКА, потом
в ДКА, после проводится минимизация
и (поскольку по условию лабиринт планарен)
делается планаризация (если передан соответствующий аргумент) 
путём выделения остовных деревьев, 
затем снова минимизация. После минимизации лабиринт иногда опять становится
непланарным, поэтому действия по планаризации и минимизации происходят в цикле.
В конце концов, лабиринт получается сильно меньше верхней границы. 
- Кроме того, при больших значениях верхней границы генерация лабиринта
может занимать большое время, так как (в силу случайности регулярки) 
иногда количество состояний выходит за рамки ограничения сверху, а еще 
иногда в лабиринте нету тупиковых финальных состояний: как я ни пытался 
это исправить, получилось только уменьшить количество таких случаев, но
не избавиться от них.
- Поскольку наиболее интересные лабиринты получаются без использования 
планаризации, была добавлена возможность генерации лабиринта с разными 
параметрами: с выполнением 
планаризации и без нее: настройки передаются через необязательный аргумент
командной строки `-p`. Для выполнения планаризации нужно передать `-p yes` 
или любую другую строку, кроме `No`. По дефолту планаризация не выполняется.
- При генерации лабиринтов длины 1-3 могут быть проблемы с бесконечным 
ожиданием.